---
title: "Land use land cover change due to green extractivism in Mozambique"
author: "Emilinah Namaganda"
date: "2022-11-01"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
Note that the `echo = FALSE` parameter was added to the code chunk to prevent
printing of the R code that generated the plot.

## Loading the necessary libraries

```{r}
library(sf) 
library(lintr) 
library(rpart) 
library(dismo) 
library(ggplot2)
library(reshape2)
library(randomForest)
library(RStoolbox)
library(caret)
library(e1071)
library(rgdal)
library(terra)
```

```{r}
# regularly remove temporary files

tmpFiles(current=TRUE, orphan=TRUE, old=TRUE, remove=F)
# I often get the following error on start up unless i clear my global
# environment from the previous session. "Error in 
#.External(list(name = "CppMethod__invoke_notvoid", address = <pointer: (nil)>,  
#:  NULL value passed as symbol address"

```


## Preprocessing Twigg (Balama), GK (Ancuabe) and Total (Palma) images

```{r}
# loading relevant image bands -----------
# TODO reorganise to start with ancb (not ancbe) and end with Plma
# TODO change ancuabe abbreviation from ancbe to ancb
# TODO start with the study areas and then input the bands close to the qa bands

studyareas_bands17 <- function(folders_images) {
  bands_all      <- list.files(folders_images,
                               recursive = T,
                               pattern = glob2rx("*B*"), 
                               full.names = TRUE)
  bands_17       <- bands_all[grep("B10", bands_all, invert = TRUE)]
  bands_list     <- list(bands_17[grep("2021.*165069", bands_17)],
                         bands_17[grep("2015.*165069", bands_17)],
                         bands_17[grep("2020.*165067", bands_17)],
                         bands_17[grep("2020.*164068", bands_17)],
                         bands_17[grep("2015.*165067", bands_17)],
                         bands_17[grep("2015.*164068", bands_17)],
                         bands_17[grep("2020.*165069", bands_17)],
                         bands_17[grep("2020.*164069", bands_17)],
                         bands_17[grep("2015.*165069", bands_17)],
                         bands_17[grep("2015.*164069", bands_17)])
  names(bands_list) <- (c("blma2021_b17",
                         "blma2015_b17",
                         "plma2020A_b17",
                         "plma2020B_b17",
                         "plma2015A_b17",
                         "plma2015B_b17",
                         "ancb2020A_b17",
                         "ancb2020B_b17",
                         "ancb2015A_b17",
                         "ancb2015B_b17"))
  bands          <- lapply(bands_list, rast)
  return(bands)
}
sa_bands <- studyareas_bands17("~/data/raw/images")
sa_bands


# removing cloud cover pixels, re-projecting to correct 
# coordinate reference system (CRS), cropping to area of interest

moz_crs    <- "+init=EPSG:32737"

# administrative posts where the mines and surrounding PACs are found

study_areasPosts <- function(mine_areas) {
  study_Posts <- list.files(mine_areas, 
                            pattern = "\\.shp$", 
                            full.names = TRUE)
  study_Postsls <- list(study_Posts[grep("blma", study_Posts)],
                        study_Posts[grep("ancb", study_Posts)],
                        study_Posts[grep("plma", study_Posts)])
  study_Postsls <- lapply(study_Postsls, vect)
  names(study_Postsls) <- c("blmapost", "ancbpost", "plmapost")
  return(study_Postsls)
}
sa_posts <- study_areasPosts("~/data/raw/mines/admposts")
sa_posts

# rectangles including mines and surrounding PACs
study_areas <- function(mine_areas) {
  study_areas <- list.files(mine_areas, 
                            pattern = "\\.shp$", 
                            full.names = TRUE)
  study_areasls <- list(study_areas[grep("blma", study_areas)],
                        study_areas[grep("ancb", study_areas)],
                        study_areas[grep("plma", study_areas)])
  study_areasls <- lapply(study_areasls, vect)
  names(study_areasls) <- c("blma", "ancb", "plma")
  return(study_areasls)
}
sa <- study_areas("~/data/raw/mines/stdyareas")

# totalAoi    <- crop(plma, total_bufSV) # created an extra AOI to 
# eliminate the ocean from analysis #TODO


study_mines <- function(mine_areas) {
  mines <- list.files(mine_areas, 
                      pattern = "\\.shp$", 
                      full.names = TRUE)
  twigg <- st_read(mines[3], 
                   query = "SELECT Mine FROM \"twigg\" WHERE FID = 0")
  gk    <- st_read(mines[1], 
                   query = "SELECT Mine FROM \"gk\" WHERE FID = 0")
  total <- st_read(mines[2], 
                   query = "SELECT Name FROM \"total\" WHERE FID = 0")
  return(list("twigg" = twigg,
              "gk" = gk,
              "total" = total))
}
mines <- study_mines("~/data/raw/mines/mines")


study_pacs <- function(mine_areas) {
  PACs       <- list.files(mine_areas, 
                     pattern = "\\.shp$", 
                     full.names = TRUE)
  twigg_pacs <- st_read(PACs[3], 
                        query = "SELECT NomeN1 FROM \"twiggPACS\"")
  total_pacs <- st_read(PACs[2], 
                        query = "SELECT Settlement FROM \"totalPACS\"")
  gk_pacs    <- st_read(PACs[1], 
                     query = "SELECT Community FROM \"gkPACS\"")
  return(list("twigg_pacs" = twigg_pacs, 
              "total_pacs" = total_pacs, 
              "gk_pacs" = gk_pacs))
}
pacs <- study_pacs("~/data/raw/mines/pacs")


sa_qabands <- function(mine_areas) {
  qa_bands <- list.files(mine_areas,
                         recursive = T,
                         pattern = "\\PIXEL.TIF$",
                         full.names = TRUE)
  sa_qa    <- list(qa_bands[grep("2021", qa_bands)], 
                   qa_bands[grep("2015.*165069", qa_bands)],
                   qa_bands[grep("2020.*165067", qa_bands)],
                   qa_bands[grep("2020.*164068", qa_bands)],
                   qa_bands[grep("2015.*165067", qa_bands)],
                   qa_bands[grep("2015.*164068", qa_bands)],
                   qa_bands[grep("2020.*165069", qa_bands)],
                   qa_bands[grep("2020.*164069", qa_bands)],
                   qa_bands[grep("2015.*165069", qa_bands)],
                   qa_bands[grep("2015.*164069", qa_bands)])
  names(sa_qa)    <- list("blma2021_qa",
                          "blma2015_qa",
                          "plma2020A_qa",
                          "plma2020B_qa",
                          "plma2015A_qa",
                          "plma2015B_qa",
                          "ancbe2020A_qa",
                          "ancbe2020B_qa",
                          "ancbe2015A_qa",
                          "ancbe2015B_qa")
  sa_qarast <- lapply(sa_qa, rast)
  return(sa_qarast)
}
qa_bands <- sa_qabands("~/data/raw/images")


qa_bandsCAT <- function(qa) {
  qab            <- qa[[1]]
  activeCat(qab) <- 0
  return(qab)
}
qa_CAT <- lapply(qa_bands, qa_bandsCAT)


aoi_L8  <- function(QAband, bands17, aoi_post) {
  cloudmask     <- classify(QAband, rbind(c(21824, 21824), c(21952, 21952)),
                         others = NA)
  b17_clear     <- mask(bands17, cloudmask)
  b17_clearProj <- terra::project(b17_clear, moz_crs)
  aoi_crop      <- crop(b17_clearProj, aoi_post, snap = "near", mask = TRUE)
  aoi_cropmsk    <- mask(aoi_crop, aoi_post)
  return(aoi_cropmsk)
}

#TODO use if else and for loop for chunk below?

aois <- function(aoi_fun, qaband, bands17, aoi_post) {
  sa_aoi        <- list(
    "blma2021"  = aoi_fun(qaband[[1]], bands17[[1]], aoi_post[[1]]),
    "blma2015"  = aoi_fun(qaband[[2]], bands17[[2]], aoi_post[[1]]),
    "plma2020A" = aoi_fun(qaband[[3]], bands17[[3]], aoi_post[[2]]),
    "plma2020B" = aoi_fun(qaband[[4]], bands17[[4]], aoi_post[[2]]),
    "plma2015A" = aoi_fun(qaband[[5]], bands17[[5]], aoi_post[[2]]),
    "plma2015B" = aoi_fun(qaband[[6]], bands17[[6]], aoi_post[[2]]),
    "ancbe2020A" = aoi_fun(qaband[[7]], bands17[[7]], aoi_post[[3]]),
    "ancbe2020B" = aoi_fun(qaband[[8]], bands17[[8]], aoi_post[[3]]),
    "ancbe2015A" = aoi_fun(qaband[[9]], bands17[[9]], aoi_post[[3]]),
    "ancbe2015B" = aoi_fun(qaband[[10]], bands17[[10]], aoi_post[[3]]))
  AncbPlma2020_2015  <- list(
    "ancbe2020" = mosaic(sa_aoi$ancbe2020A, sa_aoi$ancbe2020B),
    "ancbe2015" = mosaic(sa_aoi$ancbe2015A, sa_aoi$ancbe2015B),
    "plma2020" = mosaic(sa_aoi$plma2020A, sa_aoi$plma2020B),
    "plma2015" = mosaic(sa_aoi$plma2015A, sa_aoi$plma2015B))
  saAOI_combined <- c(sa_aoi, AncbPlma2020_2015)
  saAOI          <- saAOI_combined[-c(3:10)]
  return(saAOI)
}
aois_clean <- aois(aoi_L8, qa_CAT, sa_bands, sa_posts)
#Warning message:
#[mosaic] rasters did not align and were resampled

aois_clean_bandnames <- function(aois_list) {
  bandlist <- aois_list
  for (i in 1:length(bandlist)) {
  names(bandlist[[i]][[1:7]]) <- gsub(pattern = ".*SR",
                                   replacement = names(bandlist[i]),
                                   names(bandlist[[i]][[1:7]]))
  }
  return(bandlist)
}
aois_final <- aois_clean_bandnames(aois_clean)
aois_final

```

## Classifying the images

```{r}
# composites and indices exported to arcgis to create training samples. 
# couldn't find how to do that in R. Perhaps additional benefit of GEE is that
# it is more self-contained?

comp   <- function(bands17, x, y, z) {
  comps    <- c(bands17[[x]], bands17[[y]], bands17[[z]])
  return(comps)
}

aois_RGB <- function(bands17) {
  aois_comp <- list("blma2021_b543" = comp(bands17[[1]], 5, 4, 3),
                   "blma2015_b543" = comp(bands17[[2]], 5, 4, 3),
                   "blma2021_b654" = comp(bands17[[1]], 6, 5, 4),
                   "blma2015_b654" = comp(bands17[[2]], 6, 5, 4),
                   "ancbe2020_b543" = comp(bands17[[3]], 5, 4, 3),
                   "ancbe2015_b543" = comp(bands17[[4]], 5, 4, 3),
                   "ancbe2020_b654" = comp(bands17[[3]], 6, 5, 4),
                   "ancbe2015_b654" = comp(bands17[[4]], 6, 5, 4),
                   "plma2020_b543" = comp(bands17[[5]], 5, 4, 3),
                   "plma2015_b543" = comp(bands17[[6]], 5, 4, 3),
                   "plma2020_b654" = comp(bands17[[5]], 6, 5, 4),
                   "plma2015_b654" = comp(bands17[[6]], 6, 5, 4))
  aois_compnames <- paste0(names(aois_comp), ".tif")
  names(aois_comp) <- aois_compnames
  for (i in 1:length(aois_comp)) {
  aoisComp <- writeRaster(aois_comp[[i]],
                 file.path("~/results/output", 
                           names(aois_comp[i])),
                 overwrite=TRUE,
                 filetype="GTiff")
  }
  return(aois_comp)
}
aois_compst <- aois_RGB(aois_final)
aois_compst

comp_4bs   <- function(bands17, w, x, y, z) {
  comps    <- c(bands17[[w]], bands17[[x]], bands17[[y]], bands17[[z]])
  return(comps)
}

aois_4bs <- lapply(aois_final, w = 3, x = 4, y = 5, z = 6, comp_4bs)
aois_4bs


indices <- function(bands17, x, y) {
  bandx <- bands17[[x]]
  bandy <- bands17[[y]]
  indices <- (bandx - bandy)/(bandx + bandy)
  return(indices)
}

ndvi_fun <- function(bands17) {
  ndvi <- list("blma2021_ndvi" = indices(bands17[[1]], 5, 4),
     "blma2015_ndvi" = indices(bands17[[2]], 5, 4),
     "ancb2020_ndvi" = indices(bands17[[3]], 5, 4),
     "ancb2015_ndvi" = indices(bands17[[4]], 5, 4),
     "plma2020_ndvi" = indices(bands17[[5]], 5, 4),
     "plma2015_ndvi" = indices(bands17[[6]], 5, 4))
  ndvinames <- paste0(names(ndvi), ".tif")
  names(ndvi) <- ndvinames
  for (i in 1:length(ndvi)) {
  writeRaster(ndvi[[i]],
                 file.path("~/results/output", names(ndvi[i])),
                 overwrite=TRUE,
                 filetype="GTiff")
  }
  return(ndvi)
}
aois_ndvi <- ndvi_fun(aois_final)


## model training
# Water removed as a class from the Palma training sample. 
# It was too small to meet the accuracy needs of the classification. 
# It is now classified as wetland

trains <- list(
  "blma2021_train" = vect("~/data/temp/training-samples/blma2021_train500V3.shp"),
  "blma2015_train" = vect("~/data/temp/training-samples/blma2015_train500V2.shp"),
  "ancb2020_train" = vect("~/data/temp/training-samples/ancb2020_train500.shp"),
  "ancb2015_train" = vect("~/data/temp/training-samples/ancb2015_train500.shp"),
  "plma2020_train" = vect("~/data/temp/training-samples/plma2020_train500Weq_4cls.shp"),
  "plma2015_train" = vect("~/data/temp/training-samples/plma2015_train500_4clsv2.shp"))


# create training sample points from training sites data
# create training model  
# spatSample: In order to assure regularity when requesting a regular sample, 
# the number of cells or points returned may not be exactly the same as the 
# size requested (documentation Terra).

samps <- function(train, image_aoi) {
                set.seed(555)
  Tsamps     <- spatSample(train, 1000, method = "regular")
                print(table(as.character(Tsamps$Classname)))
  sampsXY    <- as.matrix(geom(Tsamps)[,c('x','y')])
  sampsdf    <- extract(image_aoi[[3:6]], sampsXY)
  samps      <- data.frame(class = Tsamps$Classname, sampsdf)
  sampsGeo   <- cbind(samps, sampsXY)
  sampsGeoSF <- st_as_sf(sampsGeo, coords = c("x", "y"), crs = moz_crs)
  return(sampsGeoSF)
}

study_samps <- mapply(trains, aois_final, FUN = samps, SIMPLIFY = F)
names(study_samps) <- c("blma2021_samps",
                        "blma2015_samps",
                        "ancb2020_samps",
                        "ancb2015_samps",
                        "plma2020_samps",
                        "plma2015_samps")


# inspect the spectral profiles of the training samples

lulc_classes <- list(class_BlmaAncb = c("built & bare",
                                        "dense vegetation",
                                        "sparse vegetation",
                                        "water"),
                     class_Plma = c("built & bare",
                                    "dense vegetation",
                                    "sparse vegetation",
                                    "wetland",
                                    "water"))

lulc_cols <- list(cols_BlmaAncb = c('darkorange', 
                                    'darkgreen', 
                                    'green', 
                                    'deepskyblue'),
                  cols_Plma = c('darkorange', 
                                'darkgreen', 
                                'green', 
                                'lightcyan', 
                                'deepskyblue'))

sampsSP <- function(samps) {
  sampsSP             <- aggregate(st_drop_geometry(samps)[, -1], list(samps$class), mean)
  rownames(sampsSP)   <- sampsSP[, 1]
  sampsSP             <- sampsSP[, -1]
  names(sampsSP)[1:4] <- 1:4
  sampsSP             <- t(sampsSP)
  sampsSP             <- as.data.frame(sampsSP)
  sampsSP             <- cbind(bands = rownames(sampsSP), sampsSP)
  rownames(sampsSP)   <- NULL
  sampsSP             <- melt(sampsSP, id.vars = "bands", variable.name = "lulc")
  sampsSP$bands       <- as.numeric(sampsSP$bands)
  return(sampsSP)
}

allsampsSP <- lapply(study_samps, sampsSP)


sampsSPgraph             <- list(
  "blma2021sp" = ggplot(allsampsSP[[1]], aes(bands, value)) +
    geom_line(aes(color = lulc), size = 1) +
    ggtitle("Spectral Profile Balama 2021") +
    labs(x = "Bands", y = "Reflectance") +
    scale_colour_manual("LULC", 
                    values = lulc_cols$cols_BlmaAncb,
                    labels = lulc_classes$class_BlmaAncb),
  "blma2015sp" = ggplot(allsampsSP[[2]], aes(bands, value)) +
    geom_line(aes(color = lulc), size = 1) +
    ggtitle("Spectral Profile Balama 2015") +
    labs(x = "Bands", y = "Reflectance") +
    scale_colour_manual("LULC", 
                    values = lulc_cols$cols_BlmaAncb,
                    labels = lulc_classes$class_BlmaAncb),
  "ancb2020sp" = ggplot(allsampsSP[[3]], aes(bands, value)) +
    geom_line(aes(color = lulc), size = 1) +
    ggtitle("Spectral Profile Ancuabe 2020") +
    labs(x = "Bands", y = "Reflectance") +
    scale_colour_manual("LULC", 
                    values = lulc_cols$cols_BlmaAncb,
                    labels = lulc_classes$class_BlmaAncb),
  "ancb2015sp" = ggplot(allsampsSP[[4]], aes(bands, value)) +
    geom_line(aes(color = lulc), size = 1) +
    ggtitle("Spectral Profile Ancuabe 2015") +
    labs(x = "Bands", y = "Reflectance") +
    scale_colour_manual("LULC", 
                    values = lulc_cols$cols_BlmaAncb,
                    labels = lulc_classes$class_BlmaAncb),
  "plma2020sp" = ggplot(allsampsSP[[5]], aes(bands, value)) +
    geom_line(aes(color = lulc), size = 1) +
    ggtitle("Spectral Profile Palma 2020") +
    labs(x = "Bands", y = "Reflectance") +
    scale_colour_manual("LULC", 
                    values = lulc_cols$cols_Plma,
                    labels = lulc_classes$class_Plma),
  "plma2015sp" = ggplot(allsampsSP[[6]], aes(bands, value)) +
    geom_line(aes(color = lulc), size = 1) +
    ggtitle("Spectral Profile Palma 2015") +
    labs(x = "Bands", y = "Reflectance") +
    scale_colour_manual("LULC", 
                    values = lulc_cols$cols_Plma,
                    labels = lulc_classes$class_Plma)) 


# classify images with randomforest model

# random forest

lulc <- function(samps, aoi) {
                set.seed(555)
  model      <- randomForest(as.factor(class)~., 
                             data = st_drop_geometry(samps),
                             method = 'class', 
                             minsplit = 5)
  classified <- predict(aoi, model, na.rm = TRUE)
  return(classified)
}
aois_lulc <- mapply(lulc, study_samps, aois_4bs)

# accuracies
# refer to hijmans in document as method followed. Cite.
accuracies <- list() ## up, check that you put the empty list outside function

lulc_accs <- function(sampsRF) {
  for (k in 1:5) {
                  set.seed(555)
    sampsRF    <- st_drop_geometry(sampsRF)
    sampGrps   <- kfold(sampsRF, k = 5, by = sampsRF$class)
                  print(table(sampGrps))
    train      <- sampsRF[sampGrps!= k, ]
    test       <- sampsRF[sampGrps == k, ]
    model      <- randomForest(as.factor(class)~., data=train, method = 'class', minsplit = 5)
    classfd    <- predict(model, test, na.rm = TRUE)
    accuracies[[k]] <- cbind(test$class, as.integer(classfd))
  }
  return(accuracies)
}
aoi_acc_assessment <-  lapply(study_samps, lulc_accs)

lulc_df            <- data.frame(id = 1:4, lulc = lulc_classes$class_BlmaAncb)

lulc_acc <- function(accuracies) {
  acctidy            <- do.call(rbind, accuracies)
  acctidy            <- data.frame(acctidy)
  colnames(acctidy)  <- c('observed', 'predicted')
  confmat            <- table(acctidy)
  colnames(confmat)  <- lulc_df$class
  samples            <- sum(confmat)
  samples_true       <- diag(confmat)
  overallAcc         <- sum(samples_true)/samples
  obsCases           <- apply(confmat, 1, sum)
  obsCases_true      <- obsCases/samples
  predCases          <- apply(confmat, 2, sum)
  predCases_true     <- predCases/samples
  expAcc             <- sum(obsCases_true*predCases_true)
  kappa              <- (overallAcc - expAcc)/(1 - expAcc)
  ProdAcc            <- samples_true/predCases
  UserAcc            <- samples_true/obsCases
  outAcc             <- data.frame(ProdAcc, UserAcc)
  lulc_acc           <- list(confmat, overallAcc, kappa, outAcc)
  return(lulc_acc)
}

LULC_finalaccs <- lapply(aoi_acc_assessment, lulc_acc)


# crop by wider study areas

sa_lulc <- function(lulc_ls) {
  LULC <- list("blma2021_LULC" = crop(lulc_ls[[1]], sa[[1]]),
             "blma2015_LULC" = crop(lulc_ls[[2]], sa[[1]]),
             "ancb2021_LULC" = crop(lulc_ls[[3]], sa[[2]]),
             "ancb2015_LULC" = crop(lulc_ls[[4]], sa[[2]]),
             "plma2021_LULC" = crop(lulc_ls[[5]], sa[[3]]),
             "plma2015_LULC" = crop(lulc_ls[[6]], sa[[3]]))
  LULCnames <- paste0(names(LULC), ".tif")
  names(LULC) <- LULCnames
  for (i in 1:length(LULC)) {
  writeRaster(LULC[[i]],
                 file.path("~/results/output", names(LULC[i])),
                 overwrite=TRUE,
                 filetype="GTiff")
  }
  return(LULC)
}
aois_LULC <- sa_lulc(aois_lulc)
aois_LULC

# crop by concession area

LULC_allmines <- list()

LULC_mines <-  function(cover, area_mines) {
  blma2021_twigg <- crop(cover[[1]], area_mines[[1]])
  blma2015_twigg <- crop(cover[[2]], area_mines[[1]])
  ancb2021_gk    <- crop(cover[[3]], area_mines[[2]])
  ancb2015_gk    <- crop(cover[[4]], area_mines[[2]])
  plma2021_total <- crop(cover[[5]], area_mines[[3]])
  plma2021_total <- mask(plma2021_total, area_mines[[3]])
  plma2015_total <- crop(cover[[6]], area_mines[[3]])
  plma2015_total <- mask(plma2015_total, area_mines[[3]])
  LULC_allmines  <- list("blma2021_twigg" = blma2021_twigg,
                        "blma2015_twigg" = blma2015_twigg,
                        "ancb2021_gk" = ancb2021_gk,
                        "ancb2015_gk" = ancb2015_gk,
                        "plma2021_total" = plma2021_total,
                        "plma2015_total" = plma2015_total)
  return(LULC_allmines)
}

lulc_mines <- LULC_mines(aois_lulc, mines)

# count frequency of each land use land cover

for (i in 1:length(LULC)) {
  lulc_freq <- freq(LULC[[i]])*0.0009
  print(lulc_freq)
}

# count frequency of each land use land cover

for (i in 1:length(lulc_mines)) {
  lulc_freqMines <- freq(lulc_mines[[i]])*0.0009
  print(lulc_freqMines)
}

 


```

## change detection 

```{r}
# plots

LULCdf_ls <- list()

LULC_df <- function(area_lulc) {
  for (i in 1:length(area_lulc)) {
    LULCdf <- area_lulc
    levels(LULCdf[[i]]) <- lulc_df
    LULCdf_ls[[i]] <- as.data.frame(LULCdf[[i]], xy = TRUE)
    names(LULCdf_ls) <- names(LULCdf)
    return(LULCdf_ls)
}
}
SA_LULCdf <- LULC_df(aois_LULC)

ggplot() +
  geom_tile(data = SA_LULCdf$blma2021_LULC.tif, aes(x = x, y = y, fill = lulc)) +
  geom_sf(data = mines$twigg, colour = "black", fill = NA, size = 1) +
  geom_sf(data = pacs$twigg_pacs, fill = NA) +
  geom_sf_text(data = pacs$twigg_pacs, aes(label = NomeN1)) +
  labs(x = NULL, 
       y = NULL, 
       title = "Balama 2021 land use land cover") +
  scale_fill_manual("LULC",
                    na.translate = FALSE,
                    values = lulc_cols$cols_BlmaAncb,
                    labels = lulc_classes$class_BlmaAncb) +
  coord_sf(datum = st_crs(mines$twigg))

ggplot() +
  geom_tile(data = SA_LULCdf$blma2015_LULC.tif, aes(x = x, y = y, fill = lulc)) +
  geom_sf(data = mines$twigg, colour = "black", fill = NA, size = 1) +
  geom_sf(data = pacs$twigg_pacs, fill = NA) +
  geom_sf_text(data = pacs$twigg_pacs, aes(label = NomeN1)) +
  labs(x = NULL, 
       y = NULL, 
       title = "Balama 2015 land use land cover") +
  scale_fill_manual("LULC",
                    na.translate = FALSE,
                    values = lulc_cols$cols_BlmaAncb,
                    labels = lulc_classes$class_BlmaAncb) +
  coord_sf(datum = st_crs(mines$twigg))

ggplot() +
  geom_tile(data = SA_LULCdf$ancb2021_LULC.tif, aes(x = x, y = y, fill = lulc)) +
  geom_sf(data = mines$gk, colour = "black", fill = NA, size = 1) +
  geom_sf(data = pacs$gk_pacs, fill = NA) +
  geom_sf_text(data = pacs$gk_pacs, aes(label = Community)) +
  labs(x = NULL, 
       y = NULL, 
       title = "Ancuabe 2020 land use land cover") +
  scale_fill_manual("LULC",
                    na.translate = FALSE,
                    values = lulc_cols$cols_BlmaAncb,
                    labels = lulc_classes$class_BlmaAncb) +
  coord_sf(datum = st_crs(mines$gk))

ggplot() +
  geom_tile(data = SA_LULCdf$ancb2015_LULC.tif, aes(x = x, y = y, fill = lulc)) +
  geom_sf(data = mines$gk, colour = "black", fill = NA, size = 1) +
  geom_sf(data = pacs$gk_pacs, fill = NA) +
  geom_sf_text(data = pacs$gk_pacs, aes(label = Community)) +
  labs(x = NULL, 
       y = NULL, 
       title = "Ancuabe 2015 land use land cover") +
  scale_fill_manual("LULC",
                    na.translate = FALSE,
                    values = lulc_cols$cols_BlmaAncb,
                    labels = lulc_classes$class_BlmaAncb) +
  coord_sf(datum = st_crs(mines$gk))

ggplot() +
  geom_tile(data = SA_LULCdf$plma2021_LULC.tif, aes(x = x, y = y, fill = lulc)) +
  geom_sf(data = mines$total, colour = "black", fill = NA, size = 1) +
  geom_sf(data = pacs$total_pacs, fill = NA) +
  geom_sf_text(data = pacs$total_pacs, aes(label = Settlement)) +
  labs(x = NULL, 
       y = NULL, 
       title = "Palma 2020 land use land cover") +
  scale_fill_manual("LULC",
                    na.translate = FALSE,
                    values = lulc_cols$cols_Plma,
                    labels = lulc_classes$class_Plma) +
  coord_sf(datum = st_crs(mines$total))

ggplot() +
  geom_tile(data = SA_LULCdf$plma2015_LULC.tif, aes(x = x, y = y, fill = lulc)) +
  geom_sf(data = mines$total, colour = "black", fill = NA, size = 1) +
  geom_sf(data = pacs$total_pacs, fill = NA) +
  geom_sf_text(data = pacs$total_pacs, aes(label = Settlement)) +
  labs(x = NULL, 
       y = NULL, 
       title = "Palma 2015 land use land cover") +
  scale_fill_manual("LULC",
                    na.translate = FALSE,
                    values = lulc_cols$cols_Plma,
                    labels = lulc_classes$class_Plma) +
  coord_sf(datum = st_crs(mines$total))
```

