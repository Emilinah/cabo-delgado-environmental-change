---
title: "Land use land cover change due to energy transition-induced 
        resource extraction in Mozambique"
author: "Emilinah Namaganda"
date:   "2022-11-16"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Loading the necessary libraries

```{r}
library(sf) 
library(lintr) 
library(rpart) 
library(dismo) 
library(ggplot2)
library(reshape2)
library(randomForest)
library(RStoolbox)
library(caret)
library(e1071)
library(rgdal)
library(terra)
```

## Loading the shapefiles of the resource extracting projects and their 
## surrounding areas

The study areas include the administrative posts in which the extractive 
projects are located, the projects (Twigg, GK, Total), and the area including 
the projects and the surrounding project affected communities (PACS).

```{r}
knitr::opts_chunk$set(echo = FALSE)

sa_postsfn <- function(posts) {
  saposts           <- list.files(posts, 
                            pattern = "\\.shp$", 
                            full.names = TRUE)
  saposts_ls        <- list(saposts[grep("blma", saposts)],
                        saposts[grep("ancb", saposts)],
                        saposts[grep("plma", saposts)])
  saposts_ls        <- lapply(saposts_ls, vect)
  names(saposts_ls) <- c("blmapost", "ancbpost", "plmapost")
  return(saposts_ls)
}
sa_posts <- sa_postsfn("~/data/raw/mines/admposts")


sa_minesfn <- function(mines) {
  samines <- list.files(mines, 
                      pattern = "\\.shp$", 
                      full.names = TRUE)
  twigg   <- st_read(samines[3], 
                   query = "SELECT Mine FROM \"twigg\" WHERE FID = 0")
  gk      <- st_read(samines[1], 
                   query = "SELECT Mine FROM \"gk\" WHERE FID = 0")
  total   <- st_read(samines[2], 
                   query = "SELECT Name FROM \"total\" WHERE FID = 0")
  return(list("twigg" = twigg,
              "gk"    = gk,
              "total" = total))
}
sa_mines <- sa_minesfn("~/data/raw/mines/mines")


study_areasfn <- function(mine_areas) {
  studyAreas          <- list.files(mine_areas, 
                            pattern = "\\.shp$", 
                            full.names = TRUE)
  studyAreasls        <- list(studyAreas[grep("blma", studyAreas)],
                              studyAreas[grep("ancb", studyAreas)],
                              studyAreas[grep("plma", studyAreas)])
  studyAreasls        <- lapply(studyAreasls, vect)
  names(studyAreasls) <- c("blma", "ancb", "plma")
  return(studyAreasls)
}
study_areas <- study_areasfn("~/data/raw/mines/stdyareas")


sa_pacsfn <- function(pacs) {
  PACs       <- list.files(pacs, 
                     pattern = "\\.shp$", 
                     full.names = TRUE)
  twigg_pacs <- st_read(PACs[3], 
                        query = "SELECT NomeN1 FROM \"twiggPACS\"")
  total_pacs <- st_read(PACs[2], 
                        query = "SELECT Settlement FROM \"totalPACS\"")
  gk_pacs    <- st_read(PACs[1], 
                     query = "SELECT Community FROM \"gkPACS\"")
  return(list("twigg_pacs" = twigg_pacs, 
              "total_pacs" = total_pacs, 
              "gk_pacs"    = gk_pacs))
}
sa_pacs <- sa_pacsfn("~/data/raw/mines/pacs")
```

## loading the necessary images of the study areas

The images (consisting bands 1 to 7 and qa that is, cloud pixel bands) are from 
the Landsat satellite specifically the years; 2021/2020 and 2015 covering the 
three study areas of Balama (Twigg mine), Ancuabe (GK mine), and Palma 
(Total project). 

```{r}
sa_bands17fn <- function(folders_images) {
  bands_all        <- list.files(folders_images,
                               recursive = T,
                               pattern = glob2rx("*B*"), 
                               full.names = TRUE)
  bands_17         <- bands_all[grep("B10", bands_all, invert = TRUE)]
  bands_17ls       <- list(bands_17[grep("2021.*165069", bands_17)],
                         bands_17[grep("2015.*165069", bands_17)],
                         bands_17[grep("2020.*165067", bands_17)],
                         bands_17[grep("2020.*164068", bands_17)],
                         bands_17[grep("2015.*165067", bands_17)],
                         bands_17[grep("2015.*164068", bands_17)],
                         bands_17[grep("2020.*165069", bands_17)],
                         bands_17[grep("2020.*164069", bands_17)],
                         bands_17[grep("2015.*165069", bands_17)],
                         bands_17[grep("2015.*164069", bands_17)])
  names(bands_17ls) <- (c("blma2021_b17",
                         "blma2015_b17",
                         "plma2020A_b17",
                         "plma2020B_b17",
                         "plma2015A_b17",
                         "plma2015B_b17",
                         "ancb2020A_b17",
                         "ancb2020B_b17",
                         "ancb2015A_b17",
                         "ancb2015B_b17"))
  bands             <- lapply(bands_17ls, rast)
  return(bands)
}
sa_bands <- sa_bands17fn("~/data/raw/images")


sa_qabandsfn <- function(folders_images) {
  qabands         <- list.files(folders_images,
                         recursive = T,
                         pattern = "\\PIXEL.TIF$",
                         full.names = TRUE)
  sa_qa           <- list(qabands[grep("2021", qabands)], 
                          qabands[grep("2015.*165069", qabands)],
                          qabands[grep("2020.*165067", qabands)],
                          qabands[grep("2020.*164068", qabands)],
                          qabands[grep("2015.*165067", qabands)],
                          qabands[grep("2015.*164068", qabands)],
                          qabands[grep("2020.*165069", qabands)],
                          qabands[grep("2020.*164069", qabands)],
                          qabands[grep("2015.*165069", qabands)],
                          qabands[grep("2015.*164069", qabands)])
  names(sa_qa)    <- list("blma2021_qa",
                          "blma2015_qa",
                          "plma2020A_qa",
                          "plma2020B_qa",
                          "plma2015A_qa",
                          "plma2015B_qa",
                          "ancb2020A_qa",
                          "ancb2020B_qa",
                          "ancb2015A_qa",
                          "ancb2015B_qa")
  sa_qarast <- lapply(sa_qa, rast)
  return(sa_qarast)
}
qa_bands <- sa_qabandsfn("~/data/raw/images")


qa_bandsCATfn <- function(qaBands) {
  qab            <- qaBands[[1]]
  activeCat(qab) <- 0
  return(qab)
}
qa_bandsfinal <- lapply(qa_bands, qa_bandsCATfn)
qa_bandsfinal
```

## Preprocessing the images

Cloud masks for all the images are created and used to mask the clouded regions 
from the images. The clear images - without clouds - are projected into the 
Northern Mozambique's coordinate reference system. The images are cropped to 
the area of interest (aoi) - the administrative post(s) which host the 
extractive projects. 

In cases where two images are necessary to 
cover the administrative post(s), following cropping, the images are 
mosaicked to create one image of the area.

```{r}

moz_crs    <- "+init=EPSG:32737"

images_processfn  <- function(qaBands, bands17, aoi_post) {
  cloudmask     <- classify(qaBands, 
                            rbind(c(21824, 21824), 
                                  c(21952, 21952)),
                            others = NA)
  b17_clear     <- mask(bands17, cloudmask)
  b17_clearProj <- project(b17_clear, moz_crs)
  aoi_crop      <- crop(b17_clearProj, aoi_post, snap = "near", mask = TRUE)
  aoi_cropmsk   <- mask(aoi_crop, aoi_post)
  return(aoi_cropmsk)
}

aois_imagesfn <- function(aoi_fun, qaband, bands17, aoi_post) {
  aoisImages     <- list(
    "blma2021"   = aoi_fun(qaband[[1]], bands17[[1]], aoi_post[[1]]),
    "blma2015"   = aoi_fun(qaband[[2]], bands17[[2]], aoi_post[[1]]),
    "plma2020A"  = aoi_fun(qaband[[3]], bands17[[3]], aoi_post[[3]]),
    "plma2020B"  = aoi_fun(qaband[[4]], bands17[[4]], aoi_post[[3]]),
    "plma2015A"  = aoi_fun(qaband[[5]], bands17[[5]], aoi_post[[3]]),
    "plma2015B"  = aoi_fun(qaband[[6]], bands17[[6]], aoi_post[[3]]),
    "ancb2020A"  = aoi_fun(qaband[[7]], bands17[[7]], aoi_post[[2]]),
    "ancb2020B"  = aoi_fun(qaband[[8]], bands17[[8]], aoi_post[[2]]),
    "ancb2015A"  = aoi_fun(qaband[[9]], bands17[[9]], aoi_post[[2]]),
    "ancb2015B"  = aoi_fun(qaband[[10]], bands17[[10]], aoi_post[[2]]))
  AncbPlma2020_2015  <- list(
    "ancb2020"  = mosaic(aoisImages$ancb2020A, aoisImages$ancb2020B),
    "ancb2015"  = mosaic(aoisImages$ancb2015A, aoisImages$ancb2015B),
    "plma2020"  = mosaic(aoisImages$plma2020A, aoisImages$plma2020B),
    "plma2015"  = mosaic(aoisImages$plma2015A, aoisImages$plma2015B))
  aoisImages_all <- c(aoisImages, AncbPlma2020_2015)
  aois_Images          <- aoisImages_all[-c(3:10)]
  return(aois_Images)
}
aois_images <- aois_imagesfn(images_processfn, 
                             qa_bandsfinal, 
                             sa_bands, 
                             sa_posts)


aois_imagesfinal_fn <- function(aois_imagesls) {
  imageslist                      <- aois_imagesls
  for (i in 1:length(imageslist)) {
    names(imageslist[[i]][[1:7]]) <- gsub(pattern = ".*SR",
                                          replacement = names(imageslist[i]),
                                          names(imageslist[[i]][[1:7]]))
  }
  return(imageslist)
}
aois_imagesfinal <- aois_imagesfinal_fn(aois_images)
aois_imagesfinal
```

## Classifying the images

```{r}
# composites and indices exported to arcgis to create training samples. 
# couldn't find how to do that in R. Perhaps additional benefit of GEE is that
# it is more self-contained?

comp   <- function(bands17, x, y, z) {
  comps    <- c(bands17[[x]], bands17[[y]], bands17[[z]])
  return(comps)
}

aois_RGB <- function(bands17) {
  aois_comp <- list("blma2021_b543" = comp(bands17[[1]], 5, 4, 3),
                   "blma2015_b543" = comp(bands17[[2]], 5, 4, 3),
                   "blma2021_b654" = comp(bands17[[1]], 6, 5, 4),
                   "blma2015_b654" = comp(bands17[[2]], 6, 5, 4),
                   "ancbe2020_b543" = comp(bands17[[3]], 5, 4, 3),
                   "ancbe2015_b543" = comp(bands17[[4]], 5, 4, 3),
                   "ancbe2020_b654" = comp(bands17[[3]], 6, 5, 4),
                   "ancbe2015_b654" = comp(bands17[[4]], 6, 5, 4),
                   "plma2020_b543" = comp(bands17[[5]], 5, 4, 3),
                   "plma2015_b543" = comp(bands17[[6]], 5, 4, 3),
                   "plma2020_b654" = comp(bands17[[5]], 6, 5, 4),
                   "plma2015_b654" = comp(bands17[[6]], 6, 5, 4))
  aois_compnames <- paste0(names(aois_comp), ".tif")
  names(aois_comp) <- aois_compnames
  for (i in 1:length(aois_comp)) {
  aoisComp <- writeRaster(aois_comp[[i]],
                 file.path("~/results/output", 
                           names(aois_comp[i])),
                 overwrite=TRUE,
                 filetype="GTiff")
  }
  return(aois_comp)
}
aois_compst <- aois_RGB(aois_final)
aois_compst

comp_4bs   <- function(bands17, w, x, y, z) {
  comps    <- c(bands17[[w]], bands17[[x]], bands17[[y]], bands17[[z]])
  return(comps)
}

aois_4bs <- lapply(aois_final, w = 3, x = 4, y = 5, z = 6, comp_4bs)
aois_4bs


indices <- function(bands17, x, y) {
  bandx <- bands17[[x]]
  bandy <- bands17[[y]]
  indices <- (bandx - bandy)/(bandx + bandy)
  return(indices)
}

ndvi_fun <- function(bands17) {
  ndvi <- list("blma2021_ndvi" = indices(bands17[[1]], 5, 4),
     "blma2015_ndvi" = indices(bands17[[2]], 5, 4),
     "ancb2020_ndvi" = indices(bands17[[3]], 5, 4),
     "ancb2015_ndvi" = indices(bands17[[4]], 5, 4),
     "plma2020_ndvi" = indices(bands17[[5]], 5, 4),
     "plma2015_ndvi" = indices(bands17[[6]], 5, 4))
  ndvinames <- paste0(names(ndvi), ".tif")
  names(ndvi) <- ndvinames
  for (i in 1:length(ndvi)) {
  writeRaster(ndvi[[i]],
                 file.path("~/results/output", names(ndvi[i])),
                 overwrite=TRUE,
                 filetype="GTiff")
  }
  return(ndvi)
}
aois_ndvi <- ndvi_fun(aois_final)


## model training
# Water removed as a class from the Palma training sample. 
# It was too small to meet the accuracy needs of the classification. 
# It is now classified as wetland

trains <- list(
  "blma2021_train" = vect("~/data/temp/training-samples/blma2021_train500V3.shp"),
  "blma2015_train" = vect("~/data/temp/training-samples/blma2015_train500V2.shp"),
  "ancb2020_train" = vect("~/data/temp/training-samples/ancb2020_train500.shp"),
  "ancb2015_train" = vect("~/data/temp/training-samples/ancb2015_train500.shp"),
  "plma2020_train" = vect("~/data/temp/training-samples/plma2020_train500Weq_4cls.shp"),
  "plma2015_train" = vect("~/data/temp/training-samples/plma2015_train500_4clsv2.shp"))


# create training sample points from training sites data
# create training model  
# spatSample: In order to assure regularity when requesting a regular sample, 
# the number of cells or points returned may not be exactly the same as the 
# size requested (documentation Terra).

samps <- function(train, image_aoi) {
                set.seed(555)
  Tsamps     <- spatSample(train, 1000, method = "regular")
                print(table(as.character(Tsamps$Classname)))
  sampsXY    <- as.matrix(geom(Tsamps)[,c('x','y')])
  sampsdf    <- extract(image_aoi[[3:6]], sampsXY)
  samps      <- data.frame(class = Tsamps$Classname, sampsdf)
  sampsGeo   <- cbind(samps, sampsXY)
  sampsGeoSF <- st_as_sf(sampsGeo, coords = c("x", "y"), crs = moz_crs)
  return(sampsGeoSF)
}

study_samps <- mapply(trains, aois_final, FUN = samps, SIMPLIFY = F)
names(study_samps) <- c("blma2021_samps",
                        "blma2015_samps",
                        "ancb2020_samps",
                        "ancb2015_samps",
                        "plma2020_samps",
                        "plma2015_samps")


# inspect the spectral profiles of the training samples

lulc_classes <- list(class_BlmaAncb = c("built & bare",
                                        "dense vegetation",
                                        "sparse vegetation",
                                        "water"),
                     class_Plma = c("built & bare",
                                    "dense vegetation",
                                    "sparse vegetation",
                                    "wetland",
                                    "water"))

lulc_cols <- list(cols_BlmaAncb = c('darkorange', 
                                    'darkgreen', 
                                    'green', 
                                    'deepskyblue'),
                  cols_Plma = c('darkorange', 
                                'darkgreen', 
                                'green', 
                                'lightcyan', 
                                'deepskyblue'))

sampsSP <- function(samps) {
  sampsSP             <- aggregate(st_drop_geometry(samps)[, -1], list(samps$class), mean)
  rownames(sampsSP)   <- sampsSP[, 1]
  sampsSP             <- sampsSP[, -1]
  names(sampsSP)[1:4] <- 1:4
  sampsSP             <- t(sampsSP)
  sampsSP             <- as.data.frame(sampsSP)
  sampsSP             <- cbind(bands = rownames(sampsSP), sampsSP)
  rownames(sampsSP)   <- NULL
  sampsSP             <- melt(sampsSP, id.vars = "bands", variable.name = "lulc")
  sampsSP$bands       <- as.numeric(sampsSP$bands)
  return(sampsSP)
}

allsampsSP <- lapply(study_samps, sampsSP)


sampsSPgraph             <- list(
  "blma2021sp" = ggplot(allsampsSP[[1]], aes(bands, value)) +
    geom_line(aes(color = lulc), size = 1) +
    ggtitle("Spectral Profile Balama 2021") +
    labs(x = "Bands", y = "Reflectance") +
    scale_colour_manual("LULC", 
                    values = lulc_cols$cols_BlmaAncb,
                    labels = lulc_classes$class_BlmaAncb),
  "blma2015sp" = ggplot(allsampsSP[[2]], aes(bands, value)) +
    geom_line(aes(color = lulc), size = 1) +
    ggtitle("Spectral Profile Balama 2015") +
    labs(x = "Bands", y = "Reflectance") +
    scale_colour_manual("LULC", 
                    values = lulc_cols$cols_BlmaAncb,
                    labels = lulc_classes$class_BlmaAncb),
  "ancb2020sp" = ggplot(allsampsSP[[3]], aes(bands, value)) +
    geom_line(aes(color = lulc), size = 1) +
    ggtitle("Spectral Profile Ancuabe 2020") +
    labs(x = "Bands", y = "Reflectance") +
    scale_colour_manual("LULC", 
                    values = lulc_cols$cols_BlmaAncb,
                    labels = lulc_classes$class_BlmaAncb),
  "ancb2015sp" = ggplot(allsampsSP[[4]], aes(bands, value)) +
    geom_line(aes(color = lulc), size = 1) +
    ggtitle("Spectral Profile Ancuabe 2015") +
    labs(x = "Bands", y = "Reflectance") +
    scale_colour_manual("LULC", 
                    values = lulc_cols$cols_BlmaAncb,
                    labels = lulc_classes$class_BlmaAncb),
  "plma2020sp" = ggplot(allsampsSP[[5]], aes(bands, value)) +
    geom_line(aes(color = lulc), size = 1) +
    ggtitle("Spectral Profile Palma 2020") +
    labs(x = "Bands", y = "Reflectance") +
    scale_colour_manual("LULC", 
                    values = lulc_cols$cols_Plma,
                    labels = lulc_classes$class_Plma),
  "plma2015sp" = ggplot(allsampsSP[[6]], aes(bands, value)) +
    geom_line(aes(color = lulc), size = 1) +
    ggtitle("Spectral Profile Palma 2015") +
    labs(x = "Bands", y = "Reflectance") +
    scale_colour_manual("LULC", 
                    values = lulc_cols$cols_Plma,
                    labels = lulc_classes$class_Plma)) 


# classify images with randomforest model

# random forest

lulc <- function(samps, aoi) {
                set.seed(555)
  model      <- randomForest(as.factor(class)~., 
                             data = st_drop_geometry(samps),
                             method = 'class', 
                             minsplit = 5)
  classified <- predict(aoi, model, na.rm = TRUE)
  return(classified)
}
aois_lulc <- mapply(lulc, study_samps, aois_4bs)

# accuracies
# refer to hijmans in document as method followed. Cite.
accuracies <- list() ## up, check that you put the empty list outside function

lulc_accs <- function(sampsRF) {
  for (k in 1:5) {
                  set.seed(555)
    sampsRF    <- st_drop_geometry(sampsRF)
    sampGrps   <- kfold(sampsRF, k = 5, by = sampsRF$class)
                  print(table(sampGrps))
    train      <- sampsRF[sampGrps!= k, ]
    test       <- sampsRF[sampGrps == k, ]
    model      <- randomForest(as.factor(class)~., data=train, method = 'class', minsplit = 5)
    classfd    <- predict(model, test, na.rm = TRUE)
    accuracies[[k]] <- cbind(test$class, as.integer(classfd))
  }
  return(accuracies)
}
aoi_acc_assessment <-  lapply(study_samps, lulc_accs)

lulc_df            <- data.frame(id = 1:4, lulc = lulc_classes$class_BlmaAncb)

lulc_acc <- function(accuracies) {
  acctidy            <- do.call(rbind, accuracies)
  acctidy            <- data.frame(acctidy)
  colnames(acctidy)  <- c('observed', 'predicted')
  confmat            <- table(acctidy)
  colnames(confmat)  <- lulc_df$class
  samples            <- sum(confmat)
  samples_true       <- diag(confmat)
  overallAcc         <- sum(samples_true)/samples
  obsCases           <- apply(confmat, 1, sum)
  obsCases_true      <- obsCases/samples
  predCases          <- apply(confmat, 2, sum)
  predCases_true     <- predCases/samples
  expAcc             <- sum(obsCases_true*predCases_true)
  kappa              <- (overallAcc - expAcc)/(1 - expAcc)
  ProdAcc            <- samples_true/predCases
  UserAcc            <- samples_true/obsCases
  outAcc             <- data.frame(ProdAcc, UserAcc)
  lulc_acc           <- list(confmat, overallAcc, kappa, outAcc)
  return(lulc_acc)
}

LULC_finalaccs <- lapply(aoi_acc_assessment, lulc_acc)


# crop by wider study areas

sa_lulc <- function(lulc_ls) {
  LULC <- list("blma2021_LULC" = crop(lulc_ls[[1]], sa[[1]]),
             "blma2015_LULC" = crop(lulc_ls[[2]], sa[[1]]),
             "ancb2021_LULC" = crop(lulc_ls[[3]], sa[[2]]),
             "ancb2015_LULC" = crop(lulc_ls[[4]], sa[[2]]),
             "plma2021_LULC" = crop(lulc_ls[[5]], sa[[3]]),
             "plma2015_LULC" = crop(lulc_ls[[6]], sa[[3]]))
  LULCnames <- paste0(names(LULC), ".tif")
  names(LULC) <- LULCnames
  for (i in 1:length(LULC)) {
  writeRaster(LULC[[i]],
                 file.path("~/results/output", names(LULC[i])),
                 overwrite=TRUE,
                 filetype="GTiff")
  }
  return(LULC)
}
aois_LULC <- sa_lulc(aois_lulc)
aois_LULC

# crop by concession area

LULC_allmines <- list()

LULC_mines <-  function(cover, area_mines) {
  blma2021_twigg <- crop(cover[[1]], area_mines[[1]])
  blma2015_twigg <- crop(cover[[2]], area_mines[[1]])
  ancb2021_gk    <- crop(cover[[3]], area_mines[[2]])
  ancb2015_gk    <- crop(cover[[4]], area_mines[[2]])
  plma2021_total <- crop(cover[[5]], area_mines[[3]])
  plma2021_total <- mask(plma2021_total, area_mines[[3]])
  plma2015_total <- crop(cover[[6]], area_mines[[3]])
  plma2015_total <- mask(plma2015_total, area_mines[[3]])
  LULC_allmines  <- list("blma2021_twigg" = blma2021_twigg,
                        "blma2015_twigg" = blma2015_twigg,
                        "ancb2021_gk" = ancb2021_gk,
                        "ancb2015_gk" = ancb2015_gk,
                        "plma2021_total" = plma2021_total,
                        "plma2015_total" = plma2015_total)
  return(LULC_allmines)
}

lulc_mines <- LULC_mines(aois_lulc, mines)

# count frequency of each land use land cover

for (i in 1:length(LULC)) {
  lulc_freq <- freq(LULC[[i]])*0.0009
  print(lulc_freq)
}

# count frequency of each land use land cover

for (i in 1:length(lulc_mines)) {
  lulc_freqMines <- freq(lulc_mines[[i]])*0.0009
  print(lulc_freqMines)
}

 


```

## change detection 

```{r}
# plots

LULCdf_ls <- list()

LULC_df <- function(area_lulc) {
  for (i in 1:length(area_lulc)) {
    LULCdf <- area_lulc
    levels(LULCdf[[i]]) <- lulc_df
    LULCdf_ls[[i]] <- as.data.frame(LULCdf[[i]], xy = TRUE)
    names(LULCdf_ls) <- names(LULCdf)
    return(LULCdf_ls)
}
}
SA_LULCdf <- LULC_df(aois_LULC)

ggplot() +
  geom_tile(data = SA_LULCdf$blma2021_LULC.tif, aes(x = x, y = y, fill = lulc)) +
  geom_sf(data = mines$twigg, colour = "black", fill = NA, size = 1) +
  geom_sf(data = pacs$twigg_pacs, fill = NA) +
  geom_sf_text(data = pacs$twigg_pacs, aes(label = NomeN1)) +
  labs(x = NULL, 
       y = NULL, 
       title = "Balama 2021 land use land cover") +
  scale_fill_manual("LULC",
                    na.translate = FALSE,
                    values = lulc_cols$cols_BlmaAncb,
                    labels = lulc_classes$class_BlmaAncb) +
  coord_sf(datum = st_crs(mines$twigg))

ggplot() +
  geom_tile(data = SA_LULCdf$blma2015_LULC.tif, aes(x = x, y = y, fill = lulc)) +
  geom_sf(data = mines$twigg, colour = "black", fill = NA, size = 1) +
  geom_sf(data = pacs$twigg_pacs, fill = NA) +
  geom_sf_text(data = pacs$twigg_pacs, aes(label = NomeN1)) +
  labs(x = NULL, 
       y = NULL, 
       title = "Balama 2015 land use land cover") +
  scale_fill_manual("LULC",
                    na.translate = FALSE,
                    values = lulc_cols$cols_BlmaAncb,
                    labels = lulc_classes$class_BlmaAncb) +
  coord_sf(datum = st_crs(mines$twigg))

ggplot() +
  geom_tile(data = SA_LULCdf$ancb2021_LULC.tif, aes(x = x, y = y, fill = lulc)) +
  geom_sf(data = mines$gk, colour = "black", fill = NA, size = 1) +
  geom_sf(data = pacs$gk_pacs, fill = NA) +
  geom_sf_text(data = pacs$gk_pacs, aes(label = Community)) +
  labs(x = NULL, 
       y = NULL, 
       title = "Ancuabe 2020 land use land cover") +
  scale_fill_manual("LULC",
                    na.translate = FALSE,
                    values = lulc_cols$cols_BlmaAncb,
                    labels = lulc_classes$class_BlmaAncb) +
  coord_sf(datum = st_crs(mines$gk))

ggplot() +
  geom_tile(data = SA_LULCdf$ancb2015_LULC.tif, aes(x = x, y = y, fill = lulc)) +
  geom_sf(data = mines$gk, colour = "black", fill = NA, size = 1) +
  geom_sf(data = pacs$gk_pacs, fill = NA) +
  geom_sf_text(data = pacs$gk_pacs, aes(label = Community)) +
  labs(x = NULL, 
       y = NULL, 
       title = "Ancuabe 2015 land use land cover") +
  scale_fill_manual("LULC",
                    na.translate = FALSE,
                    values = lulc_cols$cols_BlmaAncb,
                    labels = lulc_classes$class_BlmaAncb) +
  coord_sf(datum = st_crs(mines$gk))

ggplot() +
  geom_tile(data = SA_LULCdf$plma2021_LULC.tif, aes(x = x, y = y, fill = lulc)) +
  geom_sf(data = mines$total, colour = "black", fill = NA, size = 1) +
  geom_sf(data = pacs$total_pacs, fill = NA) +
  geom_sf_text(data = pacs$total_pacs, aes(label = Settlement)) +
  labs(x = NULL, 
       y = NULL, 
       title = "Palma 2020 land use land cover") +
  scale_fill_manual("LULC",
                    na.translate = FALSE,
                    values = lulc_cols$cols_Plma,
                    labels = lulc_classes$class_Plma) +
  coord_sf(datum = st_crs(mines$total))

ggplot() +
  geom_tile(data = SA_LULCdf$plma2015_LULC.tif, aes(x = x, y = y, fill = lulc)) +
  geom_sf(data = mines$total, colour = "black", fill = NA, size = 1) +
  geom_sf(data = pacs$total_pacs, fill = NA) +
  geom_sf_text(data = pacs$total_pacs, aes(label = Settlement)) +
  labs(x = NULL, 
       y = NULL, 
       title = "Palma 2015 land use land cover") +
  scale_fill_manual("LULC",
                    na.translate = FALSE,
                    values = lulc_cols$cols_Plma,
                    labels = lulc_classes$class_Plma) +
  coord_sf(datum = st_crs(mines$total))
```

